[{"title":"LeetCode第 135 场双周赛","path":"/2024/07/22/算法/LeetCode/双周赛/135/","content":"https://leetcode.cn/contest/biweekly-contest-135/ 4. 网格图操作后的最大分数https://leetcode.cn/problems/maximum-score-from-grid-operations/solutions/2851294/dp-fen-lei-tao-lun-by-tsreaper-6nkf/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123; public long maximumScore(int[][] grid) &#123; int n = grid.length; long[][] s = new long[n + 5][n + 5]; for (int j = 1; j &lt;= n; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; s[j][i] = s[j][i - 1] + grid[i - 1][j - 1]; &#125; &#125; // f[i][j][0/1]: 第i列涂j行, 1 -&gt; j &gt;= k, 0/1: 比上一列涂的少/多 long[][][] f = new long[n + 5][n + 5][2]; long ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; // i&#x27; = i // 4 f[i][j][1] = s[i - 1][j] + s[i + 1][j]; // i&#x27; = i - 1 // 1.1 if (i - 1 &gt;= 0) &#123; for (int k = 1; k &lt;= j; ++k) &#123; long w = f[i - 1][k][1] + (s[i - 1][j] - s[i - 1][k]) - s[i][k] + s[i + 1][j]; f[i][j][1] = Math.max(f[i][j][1], w); &#125; &#125; // 1.2 if (i - 1 &gt;= 1) &#123; for (int k = j + 1; k &lt;= n; ++k) &#123; // -s[j][_i] + s[j][_i] - s[j][i] + s[j + 1][i] long w = Math.max(f[i - 1][k][0], f[i - 1][k][1]) + (s[i + 1][j] - s[i][j]); f[i][j][0] = Math.max(f[i][j][0], w); &#125; &#125; // i&#x27; = i - 2 // 2.1 if (i - 2 &gt;= 1) &#123; for (int k = 1; k &lt;= j; ++k) &#123; long w = Math.max(f[i - 2][k][0], f[i - 2][k][1]) + (s[i - 1][j] - s[i - 1][k]) + s[i + 1][j]; f[i][j][1] = Math.max(f[i][j][1], w); &#125; &#125; // 2.2 if (i - 2 &gt;= 1) &#123; for (int k = j + 1; k &lt;= n; ++k) &#123; long w = Math.max(f[i - 2][k][0], f[i - 2][k][1]) + s[i + 1][j]; f[i][j][1] = Math.max(f[i][j][1], w); &#125; &#125; // i&#x27; = i - 3 // 3 if (i - 3 &gt;= 1) &#123; for (int k = 1; k &lt;= n; ++k) &#123; long w = Math.max(f[i - 3][k][0], f[i - 3][k][1]) + s[i - 1][j] + s[i + 1][j]; f[i][j][1] = Math.max(f[i][j][1], w); &#125; &#125; ans = Math.max(ans, Math.max(f[i][j][0], f[i][j][1])); &#125; &#125; return ans; &#125;&#125;","tags":["动态规划","分类讨论"],"categories":["LeetCode","双周赛"]},{"title":"LeetCode第 395 场周赛","path":"/2024/07/15/算法/LeetCode/周赛/395/","content":"https://leetcode.cn/contest/weekly-contest-395/ 2. 找出与数组相加的整数 II删除两个元素等价于$(0, 1, 2)$三个下标会剩下一个，反向枚举保留的下标$k$保证答案从小到大。 12345678910111213141516171819class Solution &#123; public int minimumAddedInteger(int[] nums1, int[] nums2) &#123; Arrays.sort(nums1); Arrays.sort(nums2); int n = nums1.length, m = nums2.length; for (int k = 2; k &gt;= 0; --k) &#123; int x = nums2[0] - nums1[k]; for (int i = k, j = 0; i &lt; n; ++i) &#123; if (j &lt; m &amp;&amp; nums1[i] + x == nums2[j]) &#123; ++j; if (j == m) &#123; return x; &#125; &#125; &#125; &#125; return -1; &#125;&#125; 3. 数组最后一个元素的最小值二进制下把$n - 1$的每一位填到$x$的$0$中。 12345678910111213141516class Solution &#123; public long minEnd(int n, int x) &#123; --n; long ans = x; int i = 0; while (n &gt; 0) &#123; // i &gt;= 32 if ((ans &gt;&gt; i &amp; 1) == 0) &#123; ans |= (n &amp; 1L) &lt;&lt; i; n &gt;&gt;= 1; &#125; ++i; &#125; return ans; &#125;&#125; 4. 找出唯一性数组的中位数长度为$n$的数组有$\\displaystyle m &#x3D; \\frac{n(1 + n)}{2}$个子数组，中位数为第$\\displaystyle k &#x3D; \\lceil \\frac{m}{2} \\rceil$个。 设$f(x)$表示$\\displaystyle \\sum_{l &#x3D; 0}^{n - 1} \\sum_{r &#x3D; l}^{n - 1} distinct(nums_{l \\dots r}) \\leq x$，问题转换为求最小的$x$满足$f(x) \\geq k$，$f(x)$具有单调性可以二分。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; static int bisect(int l, int r, Predicate&lt;Integer&gt; predicate, boolean inc) &#123; int res = -1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (predicate.test(mid)) &#123; res = mid; int _ = inc ? (l = mid + 1) : (r = mid - 1); &#125; else &#123; int _ = inc ? (r = mid - 1) : (l = mid + 1); &#125; &#125; return res; &#125; public int medianOfUniquenessArray(int[] nums) &#123; int n = nums.length; long m = (1L + n) * n / 2, k = (m + 1) / 2; return bisect(1, n, _x -&gt; &#123; Map&lt;Integer, Integer&gt; counter = new HashMap&lt;&gt;(); long fx = 0; for (int l = 0, r = 0; r &lt; n; ++r) &#123; counter.merge(nums[r], 1, Integer::sum); while (counter.size() &gt; _x) &#123; int x = nums[l]; if (counter.merge(x, -1, Integer::sum) == 0) &#123; counter.remove(x); &#125; ++l; &#125; fx += r - l + 1; if (fx &gt;= k) &#123; return true; &#125; &#125; return false; &#125;, false); &#125;&#125;","tags":["模拟","二分","双指针"],"categories":["LeetCode","周赛"]},{"title":"LeetCode第 398 场周赛","path":"/2024/07/15/算法/LeetCode/周赛/398/","content":"https://leetcode.cn/contest/weekly-contest-398/ 4. 到达第 K 级台阶的方案数设操作二次数为$j$，操作一次数为$i &#x3D; 2^j - k$。 操作一不能连续等价于在$j$个操作二前后插入$i$个操作一，方案数为$C_{j + 1}^{i}$。 答案为： $$\\sum_{j &#x3D; 0}^{29} C_{j + 1}^{i}$$ 12345678910111213141516171819202122232425262728class Comb &#123; static int N = 40; static int[][] f = new int[N][N]; static &#123; for (int i = 1; i &lt; N; ++i) &#123; f[i][0] = f[i][i] = 1; for (int j = 1; j &lt; i; ++j) &#123; f[i][j] = f[i - 1][j - 1] + f[i - 1][j]; &#125; &#125; &#125; static int c(int n, int r) &#123; return f[n][r]; &#125;&#125;class Solution &#123; static int B = 30; public int waysToReachStair(int k) &#123; int ans = 0; for (int j = 0; j &lt; B; ++j) &#123; int i = (1 &lt;&lt; j) - k; if (0 &lt;= i &amp;&amp; i &lt;= j + 1) &#123; ans += Comb.c(j + 1, i); &#125; &#125; return ans; &#125;&#125;","tags":["组合数"],"categories":["LeetCode","周赛"]},{"title":"LeetCode第 400 场周赛","path":"/2024/07/15/算法/LeetCode/周赛/400/","content":"https://leetcode.cn/contest/weekly-contest-400/ 3. 删除星号以后字典序最小的字符串1234567891011121314151617181920212223242526272829class Solution &#123; public String clearStars(String s) &#123; int n = s.length(); Deque&lt;Integer&gt;[] indices = IntStream.range(0, 26).boxed().map(_ -&gt; new ArrayDeque&lt;&gt;()).toArray(Deque[]::new); boolean[] deleted = new boolean[n]; for (int i = 0; i &lt; n; ++i) &#123; char c = s.charAt(i); if (c == &#x27;*&#x27;) &#123; for (int j = 0; j &lt; 26; ++j) &#123; if (!indices[j].isEmpty()) &#123; int index = indices[j].pop(); deleted[index] = true; break; &#125; &#125; &#125; else &#123; indices[c - &#x27;a&#x27;].push(i); &#125; &#125; StringBuilder ans = new StringBuilder(); for (int i = 0; i &lt; n; ++i) &#123; char c = s.charAt(i); if (c != &#x27;*&#x27; &amp;&amp; !deleted[i]) &#123; ans.append(c); &#125; &#125; return ans.toString(); &#125;&#125; 4. 找到按位或最接近 K 的子数组枚举$\\leq r$的不同$0$的位置，只有这些位置才会影响或运算的值。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; static int B = 30; public int minimumDifference(int[] nums, int k) &#123; int n = nums.length; int[][] last = new int[n][B]; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; B; ++j) &#123; int x = nums[i] &gt;&gt; j &amp; 1; if (i == 0) &#123; last[i][j] = x == 0 ? 0 : -1; &#125; else &#123; last[i][j] = x == 0 ? i : last[i - 1][j]; &#125; &#125; &#125; int ans = Integer.MAX_VALUE; for (int i = 0; i &lt; n; ++i) &#123; List&lt;Integer&gt; indices = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; B; ++j) &#123; if (last[i][j] &gt;= 0) &#123; indices.add(last[i][j]); &#125; &#125; indices.sort(Comparator.comparingInt(Integer::intValue).reversed()); int res = nums[i]; ans = Math.min(ans, Math.abs(res - k)); for (int index : indices) &#123; res &amp;= nums[index]; ans = Math.min(ans, Math.abs(res - k)); &#125; &#125; return ans; &#125;&#125;","tags":["模拟","位运算"],"categories":["LeetCode","周赛"]},{"title":"LeetCode第 399 场周赛","path":"/2024/07/15/算法/LeetCode/周赛/399/","content":"https://leetcode.cn/contest/weekly-contest-399/ 3. 优质数对的总数 II$nums2_j$为$\\displaystyle \\frac{nums1_i}{k}$的因子。 12345678910111213141516171819202122232425class Solution &#123; void divide(Map&lt;Integer, Integer&gt; counter, int x) &#123; for (int i = 1; i * i &lt;= x; ++i) &#123; if (x % i == 0) &#123; counter.merge(i, 1, Integer::sum); if (i * i &lt; x) &#123; counter.merge(x / i, 1, Integer::sum); &#125; &#125; &#125; &#125; public long numberOfPairs(int[] nums1, int[] nums2, int k) &#123; Map&lt;Integer, Integer&gt; counter = new HashMap&lt;&gt;(); for (int x : nums1) &#123; if (x % k == 0) &#123; divide(counter, x / k); &#125; &#125; long ans = 0; for (int x : nums2) &#123; ans += counter.getOrDefault(x, 0); &#125; return ans; &#125;&#125; 4. 不包含相邻元素的子序列的最大和1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class XNode &#123; int l, mid, r, len; // a[0]: 0 0 // a[1]: 0 ? // a[2]: ? 0 // a[3]: ? ? int[] a = new int[4]; XNode left, right; XNode(int l, int r) &#123; this.l = l; this.r = r; mid = (l + r) &gt;&gt; 1; len = r - l + 1; &#125; void merge() &#123; // 0 0 ? 0, 0 ? 0 0 a[0] = Math.max(left.a[0] + right.a[2], left.a[1] + right.a[0]); // 0 0 ? ?, 0 ? 0 ? a[1] = Math.max(left.a[0] + right.a[3], left.a[1] + right.a[1]); // ? 0 ? 0, ? ? 0 0 a[2] = Math.max(left.a[2] + right.a[2], left.a[3] + right.a[0]); // ? 0 ? ?, ? ? 0 ? a[3] = Math.max(left.a[2] + right.a[3], left.a[3] + right.a[1]); &#125;&#125;class XTree &#123; XNode root; XTree(int[] arr) &#123; int n = arr.length; root = build(arr, 0, n - 1); &#125; XNode build(int[] arr, int l, int r) &#123; XNode node = new XNode(l, r); if (l == r) &#123; node.a[3] = Math.max(arr[l], 0); return node; &#125; node.left = build(arr, l, node.mid); node.right = build(arr, node.mid + 1, r); node.merge(); return node; &#125; void modify(int i, int x) &#123; modify(i, x, root); &#125; void modify(int i, int x, XNode node) &#123; if (node.l == node.r) &#123; node.a[3] = Math.max(x, 0); return; &#125; if (i &lt;= node.mid) &#123; modify(i, x, node.left); &#125; else &#123; modify(i, x, node.right); &#125; node.merge(); &#125;&#125;class Solution &#123; static int MOD = (int) 1e9 + 7; public int maximumSumSubsequence(int[] nums, int[][] queries) &#123; XTree tree = new XTree(nums); int ans = 0; for (int[] query : queries) &#123; int pos = query[0], x = query[1]; tree.modify(pos, x); ans = (ans + tree.root.a[3]) % MOD; &#125; return ans; &#125;&#125;","tags":["数学","线段树"],"categories":["LeetCode","周赛"]},{"title":"LeetCode第 131 场双周赛","path":"/2024/07/15/算法/LeetCode/双周赛/131/","content":"https://leetcode.cn/contest/biweekly-contest-131/ 3. 所有球里面不同颜色的数目12345678910111213141516171819202122class Solution &#123; static int[] toArray(List&lt;Integer&gt; list) &#123; return list.stream().mapToInt(Integer::intValue).toArray(); &#125; public int[] queryResults(int limit, int[][] queries) &#123; Map&lt;Integer, Integer&gt; color = new HashMap&lt;&gt;(), counter = new HashMap&lt;&gt;(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int[] query : queries) &#123; int x = query[0], y = query[1]; if (color.containsKey(x)) &#123; int c = color.get(x); if (counter.merge(c, -1, Integer::sum) == 0) &#123; counter.remove(c); &#125; &#125; color.put(x, y); counter.merge(y, 1, Integer::sum); ans.add(counter.size()); &#125; return toArray(ans); &#125;&#125; 4. 物块放置查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108class XNode &#123; int l, mid, r, len; int lv, rv, mv; XNode left, right; XNode(int l, int r) &#123; this.l = l; this.r = r; mid = (l + r) &gt;&gt; 1; len = r - l + 1; &#125; XNode(XNode left, XNode right) &#123; this(left.l, right.r); this.left = left; this.right = right; &#125; void merge() &#123; mv = Math.max(left.rv + right.lv, Math.max(left.mv, right.mv)); lv = left.lv + (left.lv == left.len ? right.lv : 0); rv = right.rv + (right.rv == right.len ? left.rv : 0); &#125;&#125;class XTree &#123; XNode root; XTree(int n) &#123; root = build(0, n); &#125; XNode build(int l, int r) &#123; XNode node = new XNode(l, r); if (l == r) &#123; node.lv = node.rv = node.mv = 1; return node; &#125; node.left = build(l, node.mid); node.right = build(node.mid + 1, r); node.merge(); return node; &#125; void add(int i) &#123; add(i, root); &#125; void add(int i, XNode node) &#123; if (node.l == node.r) &#123; node.lv = node.rv = node.mv = 0; return; &#125; if (i &lt;= node.mid) &#123; add(i, node.left); &#125; else &#123; add(i, node.right); &#125; node.merge(); &#125; XNode query(int l, int r) &#123; return query(l, r, root); &#125; XNode query(int l, int r, XNode node) &#123; if (l &lt;= node.l &amp;&amp; node.r &lt;= r) &#123; return node; &#125; if (r &lt;= node.mid) &#123; return query(l, r, node.left); &#125; if (node.mid + 1 &lt;= l) &#123; return query(l, r, node.right); &#125; XNode left = query(l, r, node.left); XNode right = query(l, r, node.right); XNode res = new XNode(left, right); res.merge(); return res; &#125;&#125;class Solution &#123; int query(XTree tree, int l, int r) &#123; if (l == r) &#123; return 0; &#125; if (l + 1 == r) &#123; return 1; &#125; XNode node = tree.query(l, r, tree.root); // 没有障碍物 if (node.mv == node.len) &#123; return node.mv - 1; &#125; // 两个及以上障碍物 if (node.mv == tree.query(l + 1, r - 1).mv) &#123; return node.mv + 1; &#125; // 一个障碍物 return node.mv; &#125; public List&lt;Boolean&gt; getResults(int[][] queries) &#123; int r = Arrays.stream(queries).max(Comparator.comparingInt(query -&gt; query[1])).get()[1]; XTree tree = new XTree(r); List&lt;Boolean&gt; ans = new ArrayList&lt;&gt;(); for (int[] query : queries) &#123; int type = query[0], x = query[1]; if (type == 1) &#123; tree.add(x); &#125; else &#123; int size = query[2]; ans.add(query(tree, 0, x) &gt;= size); &#125; &#125; return ans; &#125;&#125;","tags":["模拟","线段树","分类讨论"],"categories":["LeetCode","双周赛"]},{"title":"LeetCode第 128 场双周赛","path":"/2024/07/15/算法/LeetCode/双周赛/128/","content":"https://leetcode.cn/contest/biweekly-contest-128/ 4. 边界元素是最大值的子数组数目 单调栈 维护一个单调递减栈以及栈中元素出现次数，遍历到$nums_i$时，如果$nums_i$等于栈顶元素，可以组成$count[{nums_i}]$个满足要求的子数组，累加即为答案。 123456789101112131415161718class Solution &#123; public long numberOfSubarrays(int[] nums) &#123; ArrayDeque&lt;int[]&gt; s = new ArrayDeque&lt;&gt;(List.of(new int[] &#123; Integer.MAX_VALUE, 0 &#125;)); long ans = nums.length; for (int x : nums) &#123; while (x &gt; s.peek()[0]) &#123; s.pop(); &#125; if (x == s.peek()[0]) &#123; ans += s.peek()[1]++; &#125; else &#123; // x &lt; s.peek()[0] s.push(new int[] &#123; x, 1 &#125;); &#125; &#125; return ans; &#125;&#125; 动态开点线段树 线段树支持以下操作： 单点修改 单点查询 区间置0 遍历到$nums_i$时，$tree[1 \\dots nums_i - 1]$置$0$，$tree[nums_i] + 1$，累加$tree[nums_i]$即为答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class EXNode &#123; int l, mid, r, len; int cnt; boolean zero; EXNode left, right; EXNode(int l, int r) &#123; this.l = l; this.r = r; mid = (l + r) &gt;&gt; 1; len = r - l + 1; &#125; void spread() &#123; if (left == null) &#123; left = new EXNode(l, mid); &#125; if (right == null) &#123; right = new EXNode(mid + 1, r); &#125; if (zero) &#123; left.zero(); right.zero(); zero = false; &#125; &#125; void zero() &#123; cnt = 0; zero = true; &#125;&#125;class EXTree &#123; EXNode root = new EXNode(1, (int) 1e9); int add(int i) &#123; return add(i, root); &#125; int add(int i, EXNode node) &#123; if (node.l == node.r) &#123; return ++node.cnt; &#125; node.spread(); if (i &lt;= node.mid) &#123; return add(i, node.left); &#125; else &#123; return add(i, node.right); &#125; &#125; void zero(int l, int r) &#123; zero(l, r, root); &#125; void zero(int l, int r, EXNode node) &#123; if (l &lt;= node.l &amp;&amp; node.r &lt;= r) &#123; node.zero(); return; &#125; node.spread(); if (l &lt;= node.mid) &#123; zero(l, r, node.left); &#125; if (node.mid + 1 &lt;= r) &#123; zero(l, r, node.right); &#125; &#125;&#125;class Solution &#123; public long numberOfSubarrays(int[] nums) &#123; EXTree Tree = new EXTree(); long ans = 0; for (int x : nums) &#123; if (x &gt; 1) &#123; Tree.zero(1, x - 1); &#125; ans += Tree.add(x); &#125; return ans; &#125;&#125;","tags":["线段树","单调栈"],"categories":["LeetCode","双周赛"]},{"title":"LeetCode第 129 场双周赛","path":"/2024/07/15/算法/LeetCode/双周赛/129/","content":"https://leetcode.cn/contest/biweekly-contest-129/ 3. 找出所有稳定的二进制数组 I &amp; 4. 找出所有稳定的二进制数组 II设$f[i][j][k]$表示$i$个$0$，$j$个$1$，末尾为$k$的方案数。 相同数字至多连续出现$limit$次，此时第$i + j - limit$位为$k \\oplus 1$。 对于$f[i][j][0]$，$f[i - 1][j][0]$包括了末尾连续出现$limit$个$0$的方案数，加上当前位则连续出现了$limit + 1$个$0$，为非法状态，此时需要减去此方案数$f[i - 1 - limit][j][1]$，$f[i - 1][j][0]$同理，即： $$f[i][j][k] &#x3D;\\begin{cases}f[i - 1][j][0] + f[i - 1][j][1] - f[i - 1 - limit][j][1] &amp; \\text{if $k$ &#x3D; 0} \\\\f[i][j - 1][0] + f[i][j - 1][1] - f[i][j - 1 - limit][0] &amp; \\text{if $k$ &#x3D; 1}\\end{cases}$$ 12345678910111213141516171819202122232425class Solution &#123; static int MOD = (int) 1e9 + 7; public int numberOfStableArrays(int zero, int one, int limit) &#123; int[][][] f = new int[zero + 5][one + 5][2]; for (int i = 1; i &lt;= Math.min(zero, limit); ++i) &#123; f[i][0][0] = 1; &#125; for (int j = 1; j &lt;= Math.min(one, limit); ++j) &#123; f[0][j][1] = 1; &#125; for (int i = 1; i &lt;= zero; ++i) &#123; for (int j = 1; j &lt;= one; ++j) &#123; f[i][j][0] = (f[i - 1][j][0] + f[i - 1][j][1]) % MOD; f[i][j][1] = (f[i][j - 1][0] + f[i][j - 1][1]) % MOD; if (i - 1 - limit &gt;= 0) &#123; f[i][j][0] = (f[i][j][0] - f[i - 1 - limit][j][1] + MOD) % MOD; &#125; if (j - 1 - limit &gt;= 0) &#123; f[i][j][1] = (f[i][j][1] - f[i][j - 1 - limit][0] + MOD) % MOD; &#125; &#125; &#125; return (f[zero][one][0] + f[zero][one][1]) % MOD; &#125;&#125;","tags":["动态规划"],"categories":["LeetCode","双周赛"]},{"title":"算法模板/数学","path":"/2024/07/14/算法/模板/数学/","content":"GCD &amp; LCM12345678class U &#123; static long gcd(long x, long y) &#123; return y == 0 ? x : gcd(y, x % y); &#125; static long lcm(long x, long y) &#123; return x / gcd(x, y) * y; &#125;&#125; 快速幂12345678910111213141516171819202122232425class U &#123; static long power(long a, long n) &#123; long res = 1; while (n &gt; 0) &#123; if ((n &amp; 1) == 1) &#123; res *= a; &#125; a *= a; n &gt;&gt;= 1; &#125; return res; &#125; static int power(long a, long n, int MOD) &#123; a %= MOD; int res = 1; while (n &gt; 0) &#123; if ((n &amp; 1) == 1) &#123; res = (int) (a * res % MOD); &#125; a = a * a % MOD; n &gt;&gt;= 1; &#125; return res; &#125;&#125; 素数12345678910111213141516class U &#123; static boolean isPrime(long x) &#123; if (x == 2 || x == 3) &#123; return true; &#125; if ((x % 6 != 1 &amp;&amp; x % 6 != 5) || x == 1) &#123; return false; &#125; for (int i = 5; (long) i * i &lt;= x; i += 6) &#123; if (x % i == 0 || x % (i + 2) == 0) &#123; return false; &#125; &#125; return true; &#125;&#125; 素数筛123456789101112131415161718192021222324252627class Primer &#123; static int N = 100_0005; static boolean[] isPrime = new boolean[N]; static List&lt;Integer&gt; primes = new ArrayList&lt;&gt;(); static &#123; Arrays.fill(isPrime, true); isPrime[1] = false; for (int i = 2; i &lt; N; ++i) &#123; if (isPrime[i]) &#123; primes.add(i); &#125; for (int p : primes) &#123; long k = i * p; if (k &gt;= N) &#123; break; &#125; isPrime[k] = false; if (i % p == 0) &#123; break; &#125; &#125; &#125; &#125; static boolean isPrime(int x) &#123; return isPrime[x]; &#125;&#125; 分解质因数 &amp; 因子12345678910111213141516171819202122232425262728293031323334353637383940class Factor &#123; static List&lt;Pair&lt;Integer, Integer&gt;&gt;[] factorize(int n) &#123; return IntStream.range(0, n + 5).boxed().map(Factor::factorize0).toArray(List[]::new); &#125; static List&lt;Pair&lt;Integer, Integer&gt;&gt; factorize0(int x) &#123; List&lt;Pair&lt;Integer, Integer&gt;&gt; factors = new ArrayList&lt;&gt;(); for (int i = 2; i * i &lt;= x; ++i) &#123; if (x % i == 0) &#123; int cnt = 0; while (x % i == 0) &#123; ++cnt; x /= i; &#125; factors.add(new Pair&lt;&gt;(i, cnt)); &#125; &#125; if (x &gt; 1) &#123; factors.add(new Pair&lt;&gt;(x, 1)); &#125; return factors; &#125;&#125;class Divider &#123; static List&lt;Integer&gt;[] divide(int n) &#123; return IntStream.range(0, n + 5).boxed().map(Divider::divide0).toArray(List[]::new); &#125; static List&lt;Integer&gt; divide0(int x) &#123; List&lt;Integer&gt; divisors = new ArrayList&lt;&gt;(); for (int i = 1; i * i &lt;= x; ++i) &#123; if (x % i == 0) &#123; divisors.add(i); if (i * i &lt; x) &#123; divisors.add(x / i); &#125; &#125; &#125; Collections.sort(divisors); return divisors; &#125;&#125; 组合数123456789101112131415class Comb &#123; static int N = 5005; static long[][] f = new long[N][N]; static &#123; for (int i = 1; i &lt; N; ++i) &#123; f[i][0] = f[i][i] = 1; for (int j = 1; j &lt; i; ++j) &#123; f[i][j] = f[i - 1][j - 1] + f[i - 1][j]; &#125; &#125; &#125; static long c(int n, int r) &#123; return f[n][r]; &#125;&#125; 组合数取模12345678910111213141516171819202122232425262728293031class Comb &#123; static int N = 10_0005, MOD = (int) 1e9 + 7; static int[] fact = new int[N], ifact = new int[N]; static &#123; fact[0] = 1; for (int i = 1; i &lt; N; ++i) &#123; fact[i] = (int) ((long) fact[i - 1] * i % MOD); &#125; ifact[N - 1] = inv(fact[N - 1]); for (int i = N - 2; i &gt;= 0; --i) &#123; ifact[i] = (int) ((long) ifact[i + 1] * (i + 1) % MOD); &#125; &#125; static int power(long a, long n) &#123; int res = 1; while (n &gt; 0) &#123; if ((n &amp; 1) == 1) &#123; res = (int) (a * res % MOD); &#125; a = a * a % MOD; n &gt;&gt;= 1; &#125; return res; &#125; static int inv(long x) &#123; return power(x, MOD - 2); &#125; static int c(int n, int r) &#123; return (int) ((long) fact[n] * ifact[r] % MOD * ifact[n - r] % MOD); &#125;&#125;","categories":["算法模板","数学"]},{"title":"算法模板/数据结构","path":"/2024/07/14/算法/模板/数据结构/","content":"并查集123456789101112131415161718192021222324252627282930class UnionFindSet &#123; int groups; int[] parent, size; UnionFindSet(int n) &#123; groups = n; parent = IntStream.range(0, n).toArray(); size = IntStream.range(0, n).map(_ -&gt; 1).toArray(); &#125; int find(int x) &#123; return parent[x] == x ? x : (parent[x] = find(parent[x])); &#125; boolean merge(int x, int y) &#123; if ((x = find(x)) == (y = find(y))) &#123; return false; &#125; parent[x] = y; size[y] += size[x]; --groups; return true; &#125; int sizeOf(int x) &#123; return size[find(x)]; &#125; boolean isLeader(int x) &#123; return x == find(x); &#125; boolean isConnected(int x, int y) &#123; return find(x) == find(y); &#125;&#125; 二维并查集1234567891011121314151617181920212223242526272829class UnionFindSet2D &#123; int m; UnionFindSet U; UnionFindSet2D(int n, int m) &#123; this.m = m; U = new UnionFindSet(n * m); &#125; int flat(int x, int y) &#123; return m * x + y; &#125; int find(int x, int y) &#123; return U.find(flat(x, y)); &#125; boolean merge(int x1, int y1, int x2, int y2) &#123; return U.merge(flat(x1, y1), flat(x2, y2)); &#125; int sizeOf(int x, int y) &#123; return U.sizeOf(flat(x, y)); &#125; int groups() &#123; return U.groups; &#125; boolean isLeader(int x, int y) &#123; return U.isLeader(flat(x, y)); &#125; boolean isConnected(int x1, int y1, int x2, int y2) &#123; return U.isConnected(flat(x1, y1), flat(x2, y2)); &#125;&#125; 树状数组https://oi-wiki.org/ds/fenwick/ 1234567891011121314151617181920212223242526272829303132class FenwickTree &#123; int n; long[] t1, t2; FenwickTree(int n) &#123; this.n = n; t1 = new long[n + 5]; t2 = new long[n + 5]; &#125; int lowbit(int x) &#123; return x &amp; -x; &#125; void add(int l, int r, long k) &#123; add0(l, k); add0(r + 1, -k); &#125; void add0(int i, long k) &#123; for (int __ = i; __ &lt; n; __ += lowbit(__)) &#123; t1[__] += k; t2[__] += k * i; &#125; &#125; long sum(int l, int r) &#123; return sum0(r) - sum0(l - 1); &#125; long sum0(int i) &#123; long res = 0; for (int __ = i; __ &gt; 0; __ -= lowbit(__)) &#123; res += t1[__] * (i + 1) - t2[__]; &#125; return res; &#125;&#125; 二维树状数组12345678910111213141516171819202122232425262728293031323334353637383940class FenwickTree2D &#123; long[][] t1, t2, t3, t4; FenwickTree2D(int n, int m) &#123; t1 = new long[n + 5][m + 5]; t2 = new long[n + 5][m + 5]; t3 = new long[n + 5][m + 5]; t4 = new long[n + 5][m + 5]; &#125; int lowbit(int x) &#123; return x &amp; -x; &#125; void add(int x1, int y1, int x2, int y2, long k) &#123; add0(x1, y1, k); add0(x1, y2 + 1, -k); add0(x2 + 1, y1, -k); add0(x2 + 1, y2 + 1, k); &#125; void add0(int x, int y, long k) &#123; for (int i = x; i &lt; t1.length; i += lowbit(i)) &#123; for (int j = y; j &lt; t1[0].length; j += lowbit(j)) &#123; t1[i][j] += k; t2[i][j] += k * x; t3[i][j] += k * y; t4[i][j] += k * x * y; &#125; &#125; &#125; long sum(int x1, int y1, int x2, int y2) &#123; return sum0(x2, y2) - sum0(x2, y1 - 1) - sum0(x1 - 1, y2) + sum0(x1 - 1, y1 - 1); &#125; long sum0(int x, int y) &#123; long res = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) &#123; for (int j = y; j &gt; 0; j -= lowbit(j)) &#123; res += t1[i][j] * (x + 1) * (y + 1) - t2[i][j] * (y + 1) - t3[i][j] * (x + 1) + t4[i][j]; &#125; &#125; return res; &#125;&#125; 线段树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class XNode &#123; int l, mid, r, len; XNode left, right; XNode(int l, int r) &#123; this.l = l; this.r = r; mid = (l + r) &gt;&gt; 1; len = r - l + 1; &#125; XNode(XNode left, XNode right) &#123; this(left.l, right.r); this.left = left; this.right = right; &#125; void merge() &#123;&#125; void spread() &#123;&#125; void update() &#123;&#125;&#125;class XTree &#123; XNode root; XTree(int n) &#123; root = build(1, n); &#125; XTree(int l, int r) &#123; root = build(l, r); &#125; XNode build(int l, int r) &#123; XNode node = new XNode(l, r); if (l == r) &#123; return node; &#125; node.left = build(l, node.mid); node.right = build(node.mid + 1, r); node.merge(); return node; &#125; void modify(int i) &#123; modify(i, root); &#125; void modify(int i, XNode node) &#123; if (node.l == node.r) &#123; return; &#125; node.spread(); if (i &lt;= node.mid) &#123; modify(i, node.left); &#125; else &#123; modify(i, node.right); &#125; node.merge(); &#125; void modify(int l, int r) &#123; modify(l, r, root); &#125; void modify(int l, int r, XNode node) &#123; if (l &lt;= node.l &amp;&amp; node.r &lt;= r) &#123; return; &#125; node.spread(); if (l &lt;= node.mid) &#123; modify(l, r, node.left); &#125; if (node.mid &lt; r)&#123; modify(l, r, node.right); &#125; node.merge(); &#125; void query(int i) &#123; return query(i, root); &#125; void query(int i, XNode node) &#123; if (node.l == node.r) &#123; return; &#125; node.spread(); if (i &lt;= node.mid) &#123; query(i, node.left); &#125; else &#123; query(i, node.right); &#125; &#125; void query(int l, int r) &#123; return query(l, r, root); &#125; void query(int l, int r, XNode node) &#123; if (l &lt;= node.l &amp;&amp; node.r &lt;= r) &#123; return; &#125; node.spread(); if (l &lt;= node.mid) &#123; query(l, r, node.left); &#125; if (node.mid + 1 &lt;= r) &#123; query(l, r, node.right); &#125; &#125;&#125; 值域线段树1234567891011121314151617181920212223242526272829class EXNode &#123; int l, mid, r, len; EXNode left, right; EXNode(int l, int r) &#123; this.l = l; this.r = r; mid = (l + r) &gt;&gt; 1; len = r - l + 1; &#125; void merge() &#123;&#125; void spread() &#123; if (left == null) &#123; left = new EXNode(l, mid); &#125; if (right == null) &#123; right = new EXNode(mid + 1, r); &#125; &#125; void update() &#123;&#125;&#125;class EXTree &#123; EXNode root; EXTree(int n) &#123; root = new EXNode(1, n); &#125; EXTree(int l, int r) &#123; root = new EXNode(l, r); &#125;&#125;","categories":["算法模板","数据结构"]},{"title":"算法模板/常用","path":"/2024/07/14/算法/模板/常用/","content":"容器1234567891011121314151617class U &#123; static int[] toArray(List&lt;Integer&gt; list) &#123; return list.stream().mapToInt(Integer::intValue).toArray(); &#125; static int min(int... args) &#123; return Arrays.stream(args).min().getAsInt(); &#125; static int max(int... args) &#123; return Arrays.stream(args).max().getAsInt(); &#125; static &lt;T extends Comparable&lt;T&gt;&gt; T min(Collection&lt;T&gt; collection) &#123; return Collections.min(collection); &#125; static &lt;T extends Comparable&lt;T&gt;&gt; T max(Collection&lt;T&gt; collection) &#123; return Collections.max(collection); &#125;&#125; 二分1234567891011121314151617181920212223242526272829303132333435363738394041424344class U &#123; static int bisect(int l, int r, Predicate&lt;Integer&gt; predicate, boolean inc) &#123; int res = -1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (predicate.test(mid)) &#123; res = mid; int _ = inc ? (l = mid + 1) : (r = mid - 1); &#125; else &#123; int _ = inc ? (r = mid - 1) : (l = mid + 1); &#125; &#125; return res; &#125; static long bisect(long l, long r, Predicate&lt;Long&gt; predicate, boolean inc) &#123; long res = -1; while (l &lt;= r) &#123; long mid = (l + r) &gt;&gt; 1; if (predicate.test(mid)) &#123; res = mid; long _ = inc ? (l = mid + 1) : (r = mid - 1); &#125; else &#123; long _ = inc ? (r = mid - 1) : (l = mid + 1); &#125; &#125; return res; &#125; static double bisect(double l, double r, Predicate&lt;Double&gt; predicate, boolean inc) &#123; double res = -1; while (l + 1e-8 &lt; r) &#123; double mid = (l + r) / 2; if (predicate.test(mid)) &#123; res = mid; double _ = inc ? (l = mid + 1) : (r = mid - 1); &#125; else &#123; double _ = inc ? (r = mid - 1) : (l = mid + 1); &#125; &#125; return res; &#125;&#125; 建图1234567891011121314151617181920212223class G &#123; static List&lt;Integer&gt;[] graph(int n, int[][] edges) &#123; List&lt;Integer&gt;[] g = IntStream.range(0, n).boxed().map(_ -&gt; new ArrayList&lt;&gt;()).toArray(List[]::new); for (int[] edge : edges) &#123; int u = edge[0], v = edge[1]; g[u].add(v); g[v].add(u); &#125; return g; &#125; static List&lt;Integer&gt;[] tree(int[] parent) &#123; int n = parent.length; List&lt;Integer&gt;[] g = IntStream.range(0, n).boxed().map(_ -&gt; new ArrayList&lt;&gt;()).toArray(List[]::new); for (int v = 0; v &lt; n; ++v) &#123; int u = parent[v]; if (u != -1) &#123; g[u].add(v); g[v].add(u); &#125; &#125; return g; &#125;&#125; 枚举子集12345678910111213class U &#123; // 升序 static List&lt;Integer&gt; subsets(int bitset, boolean inclusive) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int s = bitset; s &gt; 0; s = (s - 1) &amp; bitset) &#123; res.add(bitset ^ s); &#125; if (inclusive) &#123; res.add(bitset); &#125; return res; &#125;&#125; 全排列123456789101112131415161718192021222324252627282930313233343536class U &#123; static void swap(int[] arr, int l, int r) &#123; int t = arr[l]; arr[l] = arr[r]; arr[r] = t; &#125; static void reverse(int[] arr, int l, int r) &#123; while (l &lt; r) &#123; swap(ar, l, r); ++l; --r; &#125; &#125; // [1, 2, 7, 4, 3, 1] -&gt; [1, 3, 1, 2, 4, 7] static boolean nextPermutation(int[] arr) &#123; int n = arr.length; int k = -1; for (int i = n - 2; i &gt;= 0; --i) &#123; if (arr[i] &lt; arr[i + 1]) &#123; k = i; break; &#125; &#125; if (k == -1) &#123; return false; &#125; for (int i = n - 1; i &gt; k; --i) &#123; if (arr[i] &gt; arr[k]) &#123; swap(arr, k, i); reverse(arr, k + 1, n - 1); break; &#125; &#125; return true; &#125;&#125; 合并区间12345678910111213141516class U &#123; List&lt;int[]&gt; merge(int[][] intervals) &#123; Arrays.sort(intervals, Comparator.comparingInt(interval -&gt; interval[0])); List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); for (int[] interval : intervals) &#123; int m = res.size(); int l = interval[0], r = interval[1]; if (res.isEmpty() || res.get(m - 1)[1] &lt; l) &#123; res.add(new int[] &#123; l, r &#125;); &#125; else &#123; res.get(m - 1)[1] = Math.max(res.get(m - 1)[1], r); &#125; &#125; return ans; &#125;&#125; 二维前缀和123456class U &#123; // s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + grid[i - 1][j - 1]; int get(int[][] s, int x1, int y1, int x2, int y2) &#123; return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; &#125;&#125;","categories":["算法模板","常用"]},{"title":"VSCode记录","path":"/2024/07/14/工具/VSCode/","content":"配置cssC:/Program Files/Microsoft VS Code/resources/app/out/vs/workbench/workbench.desktop.main.css。 123456789/* windows全局字体 */.windows:lang(zh-Hans) &#123;\tfont-family: AaBiaoTiChuYuan, Segoe WPC, Segoe UI, Microsoft YaHei, sans-serif&#125;/* 右键菜单 */.shadow-root-host &#123;\tfont-family: AaBiaoTiChuYuan;&#125; 设置1234567891011121314151617181920&#123; &quot;window.menuBarVisibility&quot;: &quot;toggle&quot;, &quot;window.commandCenter&quot;: false, &quot;workbench.layoutControl.enabled&quot;: false, &quot;workbench.activityBar.location&quot;: &quot;top&quot;, &quot;workbench.statusBar.visible&quot;: false, &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;, &quot;workbench.tree.indent&quot;: 20, &quot;explorer.autoReveal&quot;: false, &quot;editor.fontFamily&quot;: &quot;Monaco&quot;, &quot;editor.fontSize&quot;: 19, &quot;editor.minimap.autohide&quot;: true, &quot;editor.renderWhitespace&quot;: &quot;trailing&quot;, &quot;editor.wordWrap&quot;: &quot;on&quot;, &quot;breadcrumbs.enabled&quot;: false, &quot;terminal.integrated.fontSize&quot;: 19, &quot;terminal.integrated.cursorStyle&quot;: &quot;line&quot;, &quot;files.autoSave&quot;: &quot;afterDelay&quot;, &quot;files.trimTrailingWhitespace&quot;: true,&#125; 插件1234MS-CEINTL.vscode-language-pack-zh-hansk--kato.intellij-idea-keybindingsritwickdey.LiveServerPKief.material-icon-theme Java运行安装插件vscjava.vscode-java-pack，redhat.java。 设置环境变量JAVA_HOME：C:\\Users\\Stler\\.jdks\\openjdk-22.0.1，Path下添加%JAVA_HOME%\\bin。 未识别可重启电脑。 Markdown代码片段设置 &gt; 用户代码片段 &gt; markdown.json。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&#123;\t&quot;H1&quot;: &#123; &quot;prefix&quot;: &quot;/1&quot;, &quot;body&quot;: [ &quot;# $0&quot; ]\t&#125;,\t&quot;H2&quot;: &#123; &quot;prefix&quot;: &quot;/2&quot;, &quot;body&quot;: [ &quot;## $0&quot; ]\t&#125;,\t&quot;H3&quot;: &#123; &quot;prefix&quot;: &quot;/3&quot;, &quot;body&quot;: [ &quot;### $0&quot; ]\t&#125;,\t&quot;H4&quot;: &#123; &quot;prefix&quot;: &quot;/4&quot;, &quot;body&quot;: [ &quot;#### $0&quot; ]\t&#125;,\t&quot;H5&quot;: &#123; &quot;prefix&quot;: &quot;/5&quot;, &quot;body&quot;: [ &quot;##### $0&quot; ]\t&#125;,\t&quot;H6&quot;: &#123; &quot;prefix&quot;: &quot;/6&quot;, &quot;body&quot;: [ &quot;###### $0&quot; ]\t&#125;,\t&quot;bold粗体&quot;: &#123; &quot;prefix&quot;: &quot;/b&quot;, &quot;body&quot;: [ &quot;**$1**$2&quot; ]\t&#125;,\t&quot;italic斜体&quot;: &#123; &quot;prefix&quot;: &quot;/i&quot;, &quot;body&quot;: [ &quot;*$1*$2&quot; ]\t&#125;,\t&quot;underline下划线&quot;: &#123; &quot;prefix&quot;: &quot;/u&quot;, &quot;body&quot;: [ &quot;&lt;u&gt;$1&lt;/u&gt;$2&quot; ]\t&#125;,\t&quot;line-through删除线&quot;: &#123; &quot;prefix&quot;: &quot;/x&quot;, &quot;body&quot;: [ &quot;~~$1~~$2&quot; ]\t&#125;,\t&quot;divider分割线&quot;: &#123; &quot;prefix&quot;: &quot;/d&quot;, &quot;body&quot;: [ &quot;------&quot;, &quot;$1&quot; ]\t&#125;,\t&quot;link链接&quot;: &#123; &quot;prefix&quot;: &quot;/k&quot;, &quot;body&quot;: [ &quot;[$2]($1)$3&quot; ]\t&#125;,\t&quot;image图片&quot;: &#123; &quot;prefix&quot;: &quot;/img&quot;, &quot;body&quot;: [ &quot;![$2]($1)$3&quot; ]\t&#125;,\t&quot;inline code行内代码&quot;: &#123; &quot;prefix&quot;: &quot;/cl&quot;, &quot;body&quot;: [ &quot;`$1`$2&quot; ]\t&#125;,\t&quot;code block代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/c&quot;, &quot;body&quot;: [ &quot;```$1&quot;, &quot;$0&quot;, &quot;```&quot; ]\t&#125;,\t&quot;ul有序列表&quot;: &#123; &quot;prefix&quot;: &quot;/ul&quot;, &quot;body&quot;: [ &quot;- $0&quot; ]\t&#125;,\t&quot;ol无序列表&quot;: &#123; &quot;prefix&quot;: &quot;/ol&quot;, &quot;body&quot;: [ &quot;1. $0&quot; ]\t&#125;,\t&quot;task任务列表&quot;: &#123; &quot;prefix&quot;: &quot;/task&quot;, &quot;body&quot;: [ &quot;- [ ] $0&quot; ]\t&#125;,\t&quot;quote引用&quot;: &#123; &quot;prefix&quot;: &quot;/q&quot;, &quot;body&quot;: [ &quot;&gt; $1&quot;, &quot;$2&quot; ]\t&#125;,\t&quot;table表格&quot;: &#123; &quot;prefix&quot;: &quot;/t&quot;, &quot;body&quot;: [ &quot;| $1 | $2 | $3 | $4 |&quot;, &quot;| ---- | ---- | ---- | ---- |&quot;, &quot;| $5 | $6 | $7 | $8 |&quot;, &quot;| $9 | $10 | $11 | $12 |&quot;, &quot;| $13 | $14 | $15 | $16 |&quot; ]\t&#125;,\t&quot;bash代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/bash&quot;, &quot;body&quot;: [ &quot;```bash&quot;, &quot;$0&quot;, &quot;```&quot; ]\t&#125;,\t&quot;html代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/html&quot;, &quot;body&quot;: [ &quot;```html&quot;, &quot;$0&quot;, &quot;```&quot; ]\t&#125;,\t&quot;js代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/js&quot;, &quot;body&quot;: [ &quot;```js&quot;, &quot;$0&quot;, &quot;```&quot; ]\t&#125;,\t&quot;css代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/css&quot;, &quot;body&quot;: [ &quot;```css&quot;, &quot;$0&quot;, &quot;```&quot; ]\t&#125;,\t&quot;vue代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/vue&quot;, &quot;body&quot;: [ &quot;```vue&quot;, &quot;$0&quot;, &quot;```&quot; ]\t&#125;,\t&quot;java代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/java&quot;, &quot;body&quot;: [ &quot;```java&quot;, &quot;$0&quot;, &quot;```&quot; ]\t&#125;&#125;","categories":["工具","VSCode"]},{"title":"算法模板/图论","path":"/2024/07/14/算法/模板/图论/","content":"最短路123456789101112131415161718192021222324class Dijkstra &#123; static long INF = Long.MAX_VALUE &gt;&gt; 1; static long[] run(List&lt;Pair&lt;Integer, Integer&gt;&gt;[] g, int s) &#123; Queue&lt;Pair&lt;Integer, Long&gt;&gt; q = new PriorityQueue&lt;&gt;(Comparator.comparingLong(Pair::getValue)); boolean[] vis = new boolean[g.length]; long[] dist = LongStream.range(0, g.length).map(_ -&gt; INF).toArray(); q.offer(new Pair&lt;&gt;(s, dist[s] = 0)); while (!q.isEmpty()) &#123; int u = q.poll().getKey(); if (vis[u]) &#123; continue; &#125; vis[u] = true; for (Pair&lt;Integer, Integer&gt; edge : g[u]) &#123; int v = edge.getKey(), w = edge.getValue(); long d = dist[u] + w; if (d &lt; dist[v]) &#123; q.offer(new Pair&lt;&gt;(v, dist[v] = d)); &#125; &#125; &#125; return Arrays.stream(dist).map(dist_i -&gt; dist_i == INF ? -1 : dist_i).toArray(); &#125;&#125; 最小生成树1234567891011121314151617181920212223class Kruskal &#123; static int[] parent; static int find(int x) &#123; return parent[x] == x ? x : (parent[x] = find(parent[x])); &#125; static long run(int n, int[][] edges) &#123; parent = IntStream.range(0, n).toArray(); Arrays.sort(edges, Comparator.comparingInt(edge -&gt; edge[2])); int cnt = 0; long res = 0; for (int[] edge : edges) &#123; int x = find(edge[0]), y = find(edge[1]), w = edge[2]; if (x != y) &#123; ++cnt; res += w; if (cnt == n - 1) &#123; break; &#125; &#125; &#125; return res; &#125;&#125; 二分图判断二分图1234567891011121314151617181920212223242526272829class U &#123; static boolean dfs(List&lt;Integer&gt;[] e, int[] color, int u, int c) &#123; color[u] = c; for (int v : e[u]) &#123; if (color[v] &gt; 0) &#123; if (color[v] == c) &#123; return false; &#125; &#125; else if (!dfs(e, color, v, 3 - c)) &#123; return false; &#125; &#125; return true; &#125; static boolean valid(List&lt;Integer&gt;[] e) &#123; int n = e.length; int[] color = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; if (color[i] &gt; 0) &#123; continue; &#125; if (!dfs(e, color, i, 1)) &#123; return false; &#125; &#125; return true; &#125;&#125; 二分图最大匹配1234567891011121314151617181920212223242526class U &#123; static boolean dfs(List&lt;Integer&gt;[] e, int[] vis, int[] match, int u, int sgn) &#123; if (vis[u] == sgn) &#123; return false; &#125; vis[u] = sgn; for (int v : e[u]) &#123; if (match[v] == -1 || dfs(e, vis, match, match[v], sgn)) &#123; match[v] = u; return true; &#125; &#125; return false; &#125; static int pairs(List&lt;Integer&gt;[] e) &#123; int n = e.length; int[] vis = IntStream.range(0, n).map(_ -&gt; -1).toArray(), match = IntStream.range(0, n).map(_ -&gt; -1).toArray(); int res = 0; for (int i = 0; i &lt; n; ++i) &#123; if (dfs(e, vis, match, i, i)) &#123; ++res; &#125; &#125; return res; &#125;&#125; 欧拉路径12345678910111213141516class U &#123; static void dfs(List&lt;Integer&gt;[] e, List&lt;Integer&gt; path, int u) &#123; while (!e[u].isEmpty()) &#123; int v = path.get(path.size() - 1); path.remove(path.size() - 1); dfs(e, path, v); &#125; path.add(u); &#125; static List&lt;Integer&gt; run(List&lt;Integer&gt;[] e, int s) &#123; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); dfs(e, path, s); Collections.reverse(path); return path; &#125;&#125; 网络流最大流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Edge &#123; int next, to, flow; Edge(int next, int to, int flow) &#123; this.next = next; this.to = to; this.flow = flow; &#125;&#125;class Maxflow &#123; int INF = Integer.MAX_VALUE &gt;&gt; 1; Edge[] g; int index = 1, source, destination; int[] head, cur, depth; Maxflow(int n, int m, int src, int dest) &#123; g = new Edge[(m + 5) &lt;&lt; 1]; source = src; destination = dest; head = new int[n + 5]; cur = new int[n + 5]; depth = new int[n + 5]; &#125; void add(int u, int v, int flow) &#123; g[++index] = new Edge(head[u], v, flow); head[u] = index; &#125; void addedge(int u, int v, int flow) &#123; add(u, v, flow); add(v, u, 0); &#125; boolean bfs() &#123; Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(List.of(source)); cur[source] = head[source]; Arrays.fill(depth, INF); depth[source] = 0; while (!q.isEmpty()) &#123; int u = q.poll(); if (u == destination) &#123; return true; &#125; for (int i = head[u]; i &gt; 0; i = g[i].next) &#123; int v = g[i].to, w = g[i].flow; if (w &gt; 0 &amp;&amp; depth[v] == INF) &#123; cur[v] = head[v]; depth[v] = depth[u] + 1; q.offer(v); &#125; &#125; &#125; return false; &#125; int dfs(int u, int flow) &#123; if (u == destination) &#123; return flow; &#125; int res = 0; for (int i = cur[u]; i &gt; 0; i = g[i].next) &#123; cur[u] = i; int v = g[i].to, w = g[i].flow; if (w &gt; 0 &amp;&amp; depth[u] + 1 == depth[v]) &#123; int k = dfs(v, Math.min(flow, w)); g[i].flow -= k; g[i ^ 1].flow += k; res += k; if (res == flow) &#123; break; &#125; &#125; &#125; return res; &#125; int run() &#123; int maxflow = 0; while (bfs()) &#123; maxflow += dfs(source, INF); &#125; return maxflow; &#125;&#125; 最小费用最大流1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class Edge &#123; int next, to, flow, cost; Edge(int next, int to, int flow, int cost) &#123; this.next = next; this.to = to; this.flow = flow; this.cost = cost; &#125;&#125;class Mincostflow &#123; int INF = Integer.MAX_VALUE &gt;&gt; 1; Edge[] g; int index = 1, source, destination; int[] head, cur; boolean[] vis; long[] dist; Mincostflow(int n, int m, int src, int dest) &#123; g = new Edge[(m + 5) &lt;&lt; 1]; source = src; destination = dest; head = new int[n + 5]; cur = new int[n + 5]; vis = new boolean[n + 5]; dist = new long[n + 5]; &#125; void add(int u, int v, int flow, int cost) &#123; g[++index] = new Edge(head[u], v, flow, cost); head[u] = index; &#125; void addedge(int u, int v, int flow, int cost) &#123; add(u, v, flow, cost); add(v, u, 0, -cost); &#125; boolean bfs() &#123; Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(List.of(source)); cur = Arrays.copyOf(head, head.length); Arrays.fill(dist, INF); dist[source] = 0; while (!q.isEmpty()) &#123; int u = q.poll(); vis[u] = false; for (int i = head[u]; i &gt; 0; i = g[i].next) &#123; int v = g[i].to, w = g[i].flow; long d = dist[u] + g[i].cost; if (w &gt; 0 &amp;&amp; d &lt; dist[v]) &#123; dist[v] = d; if (!vis[v]) &#123; vis[v] = true; q.offer(v); &#125; &#125; &#125; &#125; return dist[destination] != INF; &#125; int dfs(int u, int flow) &#123; if (u == destination) &#123; return flow; &#125; vis[u] = true; int res = flow; for (int i = head[u]; i &gt; 0; i = g[i].next) &#123; cur[u] = i; int v = g[i].to, w = g[i].flow; long d = dist[u] + g[i].cost; if (w &gt; 0 &amp;&amp; !vis[v] &amp;&amp; d == dist[v]) &#123; int k = dfs(v, Math.min(res, w)); g[i].flow -= k; g[i ^ 1].flow += k; res -= k; &#125; &#125; vis[u] = false; return flow - res; &#125; Pair&lt;Long, Integer&gt; run() &#123; long mincost = 0; int maxflow = 0; while (bfs()) &#123; int flow = dfs(source, INF); maxflow += flow; mincost += dist[destination] * flow; &#125; return new Pair&lt;&gt;(mincost, maxflow); &#125;&#125;","categories":["算法模板","图论"]},{"title":"算法模板/字符串","path":"/2024/07/14/算法/模板/字符串/","content":"字符串哈希1234567891011121314151617181920212223242526class Hash &#123; static int P = 131, MOD = (int) 1e9 + 7; int n; int[] h, rh, p; Hash(char[] s) &#123; n = s.length; h = new int[n + 5]; rh = new int[n + 5]; p = new int[n + 5]; p[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; h[i] = (int) (((long) h[i - 1] * P % MOD + s[i - 1]) % MOD); rh[i] = (int) (((long) rh[i - 1] * P % MOD + s[n - i]) % MOD); p[i] = (int) ((long) p[i - 1] * P % MOD); &#125; &#125; int get(int l, int r) &#123; return get(h, l, r); &#125; int get(int[] h, int l, int r) &#123; return (h[r] - (int) ((long) h[l - 1] * p[r - l + 1] % MOD) + MOD) % MOD; &#125; boolean isPalindrome(int l, int r) &#123; return get(h, l, r) == get(rh, n - r + 1, n - l + 1); &#125;&#125; 最小表示法12345678910111213141516171819int minExp(char[] s) &#123; int n = s.length, i = 0, j = 1, k = 0; while (i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n) &#123; if (s[(i + k) % n] == s[(j + k) % n]) &#123; ++k; &#125; else &#123; if (s[(i + k) % n] &gt; s[(j + k) % n]) &#123; i = i + k + 1; &#125; else &#123; j = j + k + 1; &#125; if (i == j) &#123; ++i; &#125; k = 0; &#125; &#125; return Math.min(i, j);&#125;","categories":["算法模板","字符串"]},{"title":"算法模板/动态规划","path":"/2024/07/14/算法/模板/动态规划/","content":"数位dp1234567891011121314151617181920212223242526272829303132class U &#123; static long[][] f = new long[30][100]; static int[] digit = new int[30]; static long dfs(int i, boolean zero, boolean limit, int s) &#123; if (i == 0) &#123; return zero ? 0 : 1; &#125; if (!zero &amp;&amp; !limit &amp;&amp; f[i][s] &gt; -1) &#123; return f[i][s]; &#125; long res = 0; int up = limit ? digit[i] : 9; for (int d = 0; d &lt;= up; ++d) &#123; res += dfs(i - 1, zero &amp;&amp; d == 0, limit &amp;&amp; d == up, s); &#125; if (!zero &amp;&amp; !limit) &#123; f[i][s] = res; &#125; return res; &#125; static long run(long x) &#123; int len = 0; while (x &gt; 0) &#123; digit[++len] = (int) (x % 10); x /= 10; &#125; for (long[] f_i : f) &#123; Arrays.fill(f_i, -1); &#125; return dfs(len, true, true, 0); &#125;&#125; 区间数位dp123456789101112131415161718192021222324252627282930313233343536class U &#123; static long[][] f = new long[30][100]; static int[] downdigit = new int[30], updigit = new int[30]; static long dfs(int i, boolean zero, boolean downlimit, boolean uplimit, int s) &#123; if (i == 0) &#123; return zero ? 0 : 1; &#125; if (!zero &amp;&amp; !downlimit &amp;&amp; !uplimit &amp;&amp; f[i][s] &gt; -1) &#123; return f[i][s]; &#125; long res = 0; int down = downlimit ? downdigit[i] : 0, up = uplimit ? updigit[i] : 9; for (int d = down; d &lt;= up; ++d) &#123; res += dfs(i - 1, zero &amp;&amp; d == 0, downlimit &amp;&amp; d == down, uplimit &amp;&amp; d == up, s); &#125; if (!zero &amp;&amp; !downlimit &amp;&amp; !uplimit) &#123; f[i][s] = res; &#125; return res; &#125; static long run(int l, int r) &#123; toArray(downdigit, l); toArray(updigit, r); for (long[] f_i : f) &#123; Arrays.fill(f_i, -1); &#125; return dfs(downdigit.length - 1, true, true, true, 0); &#125; static void toArray(int[] digit, long x) &#123; int len = 0; while (x &gt; 0) &#123; digit[++len] = (int) (x % 10); x /= 10; &#125; &#125;&#125;","categories":["算法模板","动态规划"]},{"title":"JetBrains记录","path":"/2024/07/14/工具/JetBrains/","content":"激活https://3.jetbra.in 选择带*的网址，下载jetbra.zip，解压并运行scripts/install-all-users.vbs。 解压后的文件不可删除，移动位置后需重新执行脚本。 配置设置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071外观与行为 外观 主题：VSCode Dark Modern ☑ 使用自定义字体：AaCuyuan 大小：14 UI选项 ◻ 在主工具栏中使用项目颜色 新UI ☑ 紧凑模式编辑器 常规 自动导入 Java ☑ 动态添加明确的 import ☑ 动态优化 import 外观 ☑ 对嵌入提示使用编辑器字体 编辑器标签页 打开策略 ☑ 启用预览标签页 代码编辑 移动文本光标时高亮显示 ◻ 匹配大括号 字体 字体：Monaco 大小：19.0 行高：1.2 配色方案 常规 弱警告 ◻ 效果 代码样式 Java 代码生成 注释代码 ◻ 行注释在第一列 ☑ 在行注释开始处添加空格 ☑ 强制重新格式化 ◻ 注释块在第一列 ☑ 在块注释周围添加空格 HTML 其他 空格 ☑ 在空的标签 在第一个特性前换行：当多行时 在最后一个特性后前换行：当多行时 JavaScript 空格 内部 ☑ 对象文字大括号 ☑ ES6 导入/导出大括号 嵌入提示 ◻ Code Version ◻ 继承者 ◻ 相关问题 ◻ 用法 ◻ 使用 AI 生成文档 ◻ 代码作者 形参名称 ◻ JavaScript ◻ 标记的模板实参 ◻ 管道运算符 类型 ◻ JavaScript ◻ 变量和字段 ◻ 圆括号中的形参 ◻ 未使用括号括起来的单个形参 ◻ 函数返回值类型工具 终端 应用程序设置 光标形状：垂直线 插件12345613710-chinese-simplified-language-pack10044-atom-material-icons19177-vscode-theme13643-monokai-pro-theme10080-rainbow-brackets18824-codeglance-pro","categories":["工具","JetBrains"]},{"title":"Stellar记录","path":"/2024/07/13/工具/Hexo/Stellar/","content":"配置文件_config.Stellar.yml。 12345678910111213141516171819202122232425article: auto_excerpt: 0plugins: mathjax: enable: trueinject: head: &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-web/style.css&quot; /&gt;style: font-size: codeblock: 1rem font-family: logo: &quot;LXGW WenKai Screen&quot; body: &quot;LXGW WenKai Screen&quot; color: theme: hsl(230, 100%, 69.4%) link: hsl(230, 100%, 69.4%) animated_avatar: background: &#x27;&#x27; leftbar: background: var(--leftbar-bg) background-image: &#x27;&#x27; blur-px: 0 图标_data/icons.yml。 1234default:leftbar: &lt;svg t=&quot;1721675772853&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;9966&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M969.536 402.944a22.4 22.4 0 0 0-22.336 22.08V273.088a22.4 22.4 0 0 0 44.736-0.128h0.064V160a22.4 22.4 0 0 0-22.4-22.4H54.4a22.528 22.528 0 0 0-22.4 22.4v604.608c0 12.288 10.112 22.4 22.4 22.4h915.2a22.4 22.4 0 0 0 22.4-22.4V425.344a22.4 22.4 0 0 0-22.464-22.4z&quot; fill=&quot;&quot; p-id=&quot;9967&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M969.6 328m-22.4 0a22.4 22.4 0 1 0 44.8 0 22.4 22.4 0 1 0-44.8 0Z&quot; fill=&quot;&quot; p-id=&quot;9968&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M77.44 631.168a0.64 0.64 0 0 1-0.64-0.64V189.376a0.64 0.64 0 0 1 0.64-0.64h869.184c0.256 0 0.64 0.256 0.64 0.64v441.152c0 0.32-0.384 0.64-0.64 0.64H77.44z&quot; fill=&quot;#545454&quot; p-id=&quot;9969&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M77.44 740.032a0.64 0.64 0 0 1-0.64-0.64v-69.12a0.64 0.64 0 0 1 0.64-0.64h869.184c0.256 0 0.64 0.32 0.64 0.64v69.12c0 0.32-0.384 0.64-0.64 0.64H77.44z&quot; fill=&quot;#E0E0E0&quot; p-id=&quot;9970&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M76.8 631.168h870.464v44.8H76.8zM637.12 875.776H386.816l19.264-88.768h211.904z&quot; fill=&quot;&quot; p-id=&quot;9971&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M431.68 875.776l19.2-88.768h122.368l19.136 88.768z&quot; fill=&quot;#E0E0E0&quot; p-id=&quot;9972&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M721.984 888a16 16 0 0 1-16 16H318.016a16 16 0 0 1 0-32h388.032a16 16 0 0 1 15.936 16z&quot; fill=&quot;&quot; p-id=&quot;9973&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 706.688m-18.176 0a18.176 18.176 0 1 0 36.352 0 18.176 18.176 0 1 0-36.352 0Z&quot; fill=&quot;&quot; p-id=&quot;9974&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M366.272 445.76a22.464 22.464 0 0 1-31.68 0 22.464 22.464 0 0 1 0-31.68l134.272-134.272a22.464 22.464 0 0 1 31.68 0 22.464 22.464 0 0 1 0 31.68L366.272 445.76z&quot; fill=&quot;#FFFFFF&quot; p-id=&quot;9975&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M407.424 540.16a22.464 22.464 0 0 1-31.68 0 22.528 22.528 0 0 1 0-31.744l67.328-67.264a22.464 22.464 0 0 1 31.68 0 22.464 22.464 0 0 1 0 31.68L407.424 540.16z&quot; fill=&quot;#FFFFFF&quot; p-id=&quot;9976&quot;&gt;&lt;/path&gt;&lt;/svg&gt;default:rightbar: &lt;svg t=&quot;1715527921227&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;132681&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M91.89 238.457c-29.899 0-54.133 24.239-54.133 54.134 0 29.899 24.234 54.137 54.133 54.137s54.138-24.238 54.138-54.137c0-29.896-24.239-54.134-54.138-54.134z&quot; fill=&quot;#E5594F&quot; p-id=&quot;132682&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M91.89 462.463c-29.899 0-54.133 24.239-54.133 54.139 0 29.895 24.234 54.133 54.133 54.133s54.138-24.238 54.138-54.133c0-29.9-24.239-54.139-54.138-54.139z&quot; fill=&quot;#C45FA0&quot; p-id=&quot;132683&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M91.89 686.475c-29.899 0-54.133 24.237-54.133 54.133 0 29.899 24.234 54.138 54.133 54.138s54.138-24.238 54.138-54.138c0-29.896-24.239-54.133-54.138-54.133z&quot; fill=&quot;#F39A2B&quot; p-id=&quot;132684&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M941.26 234.723H328.964c-28.867 0-52.263 23.4-52.263 52.268v3.734c0 28.868 23.396 52.269 52.263 52.269H941.26c28.869 0 52.269-23.401 52.269-52.269v-3.734c-0.001-28.868-23.4-52.268-52.269-52.268z&quot; fill=&quot;#F0D043&quot; p-id=&quot;132685&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M941.26 682.74H328.964c-28.867 0-52.263 23.399-52.263 52.268v3.734c0 28.863 23.396 52.269 52.263 52.269H941.26c28.869 0 52.269-23.405 52.269-52.269v-3.734c-0.001-28.868-23.4-52.268-52.269-52.268z&quot; fill=&quot;#4A5699&quot; p-id=&quot;132686&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M709.781 458.729H328.964c-28.867 0-52.263 23.4-52.263 52.269v3.734c0 28.873 23.396 52.269 52.263 52.269h380.817c28.866 0 52.271-23.396 52.271-52.269v-3.734c0.001-28.869-23.405-52.269-52.271-52.269z&quot; fill=&quot;#E5594F&quot; p-id=&quot;132687&quot;&gt;&lt;/path&gt;&lt;/svg&gt;default:calendar: &lt;svg t=&quot;1715526145742&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;14632&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M879.28 916.37H145.9c-9.86 0-17.86-7.99-17.86-17.86V234.64c0-9.86 7.99-17.86 17.86-17.86h733.38c9.86 0 17.86 7.99 17.86 17.86v663.88c0 9.86-7.99 17.85-17.86 17.85z&quot; fill=&quot;#FFFFFF&quot; p-id=&quot;14633&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M844.64 216.78h-57.78v699.59h57.78c29 0 52.5-23.51 52.5-52.5V269.28c0-28.99-23.51-52.5-52.5-52.5z&quot; fill=&quot;#D0E2F3&quot; p-id=&quot;14634&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.05 269.28V431.7h769.09V269.28c0-29-23.51-52.5-52.5-52.5H180.55c-29 0-52.5 23.51-52.5 52.5z&quot; fill=&quot;#EE8C98&quot; p-id=&quot;14635&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M897.14 431.7V269.28c0-29-23.51-52.5-52.5-52.5h-57.78V431.7h110.28z&quot; fill=&quot;#D96478&quot; p-id=&quot;14636&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M844.64 934.02H180.55c-38.68 0-70.14-31.47-70.14-70.14v-594.6c0-38.68 31.47-70.14 70.14-70.14h664.09c38.68 0 70.14 31.47 70.14 70.14v594.59c0 38.68-31.47 70.15-70.14 70.15z m-664.09-699.6c-19.22 0-34.86 15.64-34.86 34.86v594.59c0 19.22 15.64 34.86 34.86 34.86h664.09c19.22 0 34.86-15.64 34.86-34.86V269.28c0-19.22-15.64-34.86-34.86-34.86H180.55z&quot; fill=&quot;#49416F&quot; p-id=&quot;14637&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M897.14 449.34h-769.1c-9.74 0-17.64-7.9-17.64-17.64V269.28c0-38.68 31.47-70.14 70.14-70.14h664.09c38.68 0 70.14 31.47 70.14 70.14V431.7c0.01 9.74-7.89 17.64-17.63 17.64z m-751.45-35.28H879.5V269.28c0-19.22-15.64-34.86-34.86-34.86H180.55c-19.22 0-34.86 15.64-34.86 34.86v144.78z&quot; fill=&quot;#49416F&quot; p-id=&quot;14638&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M356.25 317.69h-73.86c-1.24 0-2.25-1.01-2.25-2.25V118.12c0-1.24 1.01-2.25 2.25-2.25h73.86c1.24 0 2.25 1.01 2.25 2.25v197.33c0 1.24-1.01 2.24-2.25 2.24zM705.87 317.69c-21.64 0-39.18-17.54-39.18-39.18V155.05c0-21.64 17.54-39.18 39.18-39.18s39.18 17.54 39.18 39.18v123.47c-0.01 21.63-17.55 39.17-39.18 39.17z&quot; fill=&quot;#A0C8EA&quot; p-id=&quot;14639&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M499.26 641.69c18.28 17.91 27.24 41.79 27.24 65.3s-8.96 47.39-27.24 65.67a92.988 92.988 0 0 1-65.67 27.24c-23.51 0-47.39-9.33-65.3-27.24-8.21-8.21-8.21-21.64 0-29.85s21.64-8.21 29.85 0c9.7 9.7 22.39 14.55 35.45 14.55 13.06 0 25.75-4.85 35.82-14.55 10.08-10.07 14.93-22.76 14.93-35.82 0-13.06-4.85-25.75-14.93-35.45-9.7-10.07-22.39-14.55-35.45-14.93-5.97 0.37-11.57-2.24-15.3-6.72-0.37 0-0.37 0-0.37-0.37-8.58-8.21-8.58-21.27-0.75-29.85l38.06-38.81h-60.45c-11.57 0-20.9-9.33-20.9-21.27 0-11.57 9.33-20.9 20.9-20.9h110.08c11.94 0 21.27 9.33 21.27 20.9 0 3.73-1.12 7.09-2.61 10.07-1.12 1.87-2.24 3.73-3.73 5.22l-47.02 48.51c9.7 4.49 18.66 10.46 26.12 18.3zM663.06 559.6v220.16c0 11.57-9.7 20.52-20.9 20.52-11.57 0-20.52-8.96-20.52-20.52v-183.6l-14.93 8.58c-3.36 2.24-7.09 2.99-10.45 2.99-7.09 0-13.81-3.73-17.54-10.45-6.34-9.33-2.98-22.39 6.72-27.99l45.9-27.24c0.37-0.37 1.12-0.37 1.49-0.75 0.75 0 1.12-0.75 1.87-1.12 0.75 0 1.49-0.37 2.24-0.37 0.37-0.37 1.12-0.37 1.49-0.37 0.75-0.37 1.87-0.37 2.61-0.37h4.1c0.37 0.37 1.12 0.37 1.49 0.37 1.12 0 1.49 0.37 2.24 0.75 0.37 0 1.12 0 1.49 0.37 1.12 0.75 1.49 1.12 2.24 1.12 0.37 0.37 0.75 0.75 1.49 1.12 0.37 0.37 1.12 0.75 1.49 1.12 0.75 0.37 1.12 1.12 1.49 1.49 0.37 0.37 0.75 0.75 1.12 1.49l1.49 1.49 0.37 0.75c0 0.37 0.37 0.75 0.37 1.12 0.37 0.75 0.75 1.12 0.75 1.86 0.37 0.75 0.37 1.49 0.75 1.87 0 0.75 0.37 1.49 0.37 1.87 0 1.12 0 1.86 0.75 2.61 0.02 0.38 0.02 0.75 0.02 1.13z&quot; fill=&quot;#49416F&quot; p-id=&quot;14640&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M319.32 335.33c-31.33 0-56.82-25.49-56.82-56.82V155.05c0-31.33 25.49-56.82 56.82-56.82s56.82 25.49 56.82 56.82v123.47c0 31.33-25.49 56.81-56.82 56.81z m0-201.82c-11.88 0-21.53 9.66-21.53 21.54v123.47c0 11.87 9.66 21.53 21.53 21.53s21.53-9.66 21.53-21.53V155.05c0-11.88-9.66-21.54-21.53-21.54zM705.87 335.33c-31.33 0-56.82-25.49-56.82-56.82V155.05c0-31.33 25.49-56.82 56.82-56.82 31.33 0 56.82 25.49 56.82 56.82v123.47c-0.01 31.33-25.49 56.81-56.82 56.81z m0-201.82c-11.88 0-21.53 9.66-21.53 21.54v123.47c0 11.87 9.66 21.53 21.53 21.53s21.53-9.66 21.53-21.53V155.05c0-11.88-9.66-21.54-21.53-21.54z&quot; fill=&quot;#49416F&quot; p-id=&quot;14641&quot;&gt;&lt;/path&gt;&lt;/svg&gt;default:category: &lt;svg t=&quot;1721647683246&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;17322&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M51.2 258.56h870.4c30.72 0 51.2 20.48 51.2 51.2v512c0 30.72-20.48 51.2-51.2 51.2H102.4c-30.72 0-51.2-20.48-51.2-51.2v-563.2z&quot; fill=&quot;#FFCB7E&quot; p-id=&quot;17323&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M102.4 156.16h235.52c15.36 0 25.6 5.12 35.84 15.36L460.8 258.56H51.2v-51.2c0-30.72 20.48-51.2 51.2-51.2z&quot; fill=&quot;#E4AC57&quot; p-id=&quot;17324&quot;&gt;&lt;/path&gt;&lt;/svg&gt; csssource/css/main.styl。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647::-webkit-scrollbar width: 4px::-webkit-scrollbar-thumb background-color: #c3c0c1 border-radius: 999px:root --width-main: 960px.l_body[layout=&quot;post&quot;] .l_left opacity: 0 &amp;:hover opacity: 1.l_body[leftbar] .float-panel,.l_body[rightbar] .float-panel box-shadow: 0 1px 2px 0px rgba(0, 0, 0, 0.1).float-panel border: 1px solid var(--block) box-shadow: 0 1px 2px 0px rgba(0, 0, 0, 0.1) button &amp;:not(:last-child) border-bottom: 1px solid var(--block) &amp;:hover background-color: var(--block)a:not([class]) transition: none !important.post-list #cats a.cat.child padding-left: 2.5remdiv.toast padding: 0.5rem 1rem border-radius: 999px.md-text.content h1 font-weight: 500 a.headerlink:before content: &quot;:&quot; h2 a.headerlink:before content: &quot;&quot; 卡片source/css/_defines/func.styl。 12345678floatable-float() box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1), 0 4px 16px rgba(0, 0, 0, 0.1) // transform: translate3d(0, -2px, 0)hoverable-card() ondark() &amp;:hover box-shadow: 0 0 0 1px $color-theme 设备适配source/css/_defines/const.styl。 12$device-mobile-max = 1439px$device-laptop = 1439px 文章卡片添加标签layout/_partial/main/post_list/post_card.ejs在cat注释的代码块（76行）后添加以下代码。 123456789101112131415161718192021if (post.tags &amp;&amp; post.tags.length &gt; 0) &#123; if (post.layout === &#x27;post&#x27; &amp;&amp; post.tags &amp;&amp; post.tags.length &gt; 0) &#123; var tags = []; if (post.categories) &#123; post.tags.forEach((cat, i) =&gt; &#123; tags.push(cat.name); &#125;); &#125; if (tags.length &gt; 0) &#123; el += &#x27;&lt;span class=&quot;cap breadcrumb&quot;&gt;&#x27;; el += icon(&#x27;default:tag&#x27;); tags.forEach((tag, i) =&gt; &#123; el += `&lt;span&gt;$&#123;tag&#125;&lt;/span&gt;`; if (i &lt; tags.length - 1) &#123; el += &#x27;，&#x27;; &#125; &#125;); el += &#x27;&lt;/span&gt;&#x27;; &#125; &#125;&#125; _data/icons.yml。 1default:tag: &lt;svg t=&quot;1721645006927&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;4169&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M698.181818 876.916364l-160.116363-147.781819-160.116364 147.781819V222.487273a45.149091 45.149091 0 0 1 45.381818-45.149091h242.036364A33.047273 33.047273 0 0 1 698.181818 209.454545z&quot; fill=&quot;#598CC9&quot; p-id=&quot;4170&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M665.367273 177.105455H423.796364a45.149091 45.149091 0 0 0-45.149091 46.545454v330.938182H698.181818V209.454545a33.28 33.28 0 0 0-32.814545-32.34909z&quot; fill=&quot;#EB6363&quot; p-id=&quot;4171&quot;&gt;&lt;/path&gt;&lt;/svg&gt;","categories":["工具","Hexo"]},{"title":"Hexo记录","path":"/2024/07/13/工具/Hexo/Hexo/","content":"运行环境Node.jshttps://nodejs.org/en 1npm i -g cnpm --registry=https://registry.npmmirror.com Git如果只在本地运行，不需要安装该工具。 https://git-scm.com/download/win 64-bit Git for Windows Setup.。 12git config --global user.name Stlergit config --global user.email 3393401063@qq.com 安装1npm i -g hexo-cli 在空文件夹下执行以下命令。 12hexo inithexo s 部署1npm i hexo-deployer-git _config.yml。 1234deploy: type: git repo: https://github.com/Stler4j/Stler4j.github.io.git branch: main 部署。 12hexo cleanhexo d 配置文件_config.yml。 12345678title: Stler&#x27;s Blogauthor: Stleravatar: https://ts1.cn.mm.bing.net/th/id/R-C.4e6232794f523ca4ae68a487db22ec7a?rik=3IigK%2bYxioLWzA&amp;riu=http%3a%2f%2fpic.52112.com%2fJPG-180514%2f180514_153%2fsC3BsPCXLt_small.jpg&amp;ehk=pQKfO1Ioo0cLwwlTNpiytZJJJhEfBwa38%2bSkq%2bDxPzc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0language: zh-CNtimezone: Asia/Shanghaiindex_generator: per_page: 0 安装主题以Stellar为例。 12cd themesgit clone https://github.com/xaoxuu/hexo-theme-stellar Stellar _config.yml。 1theme: Stellar","categories":["工具","Hexo"]}]